[1,["70TB+7DuxJia4HNNM4hQ2R@6c48a","62/395PatNO55qBxDz3qPU@6c48a","74iWZWnGJJDpytPZI/26o9@6c48a","42WAdJnmBHZLBdF5KFbZBw"],["Color_RampSampler","Dissolve_NoiseSampler","Sprite_GraphicSampler","_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_techIdx","_states","_defines","_props"],-1,12]],[[0,0,1,2,4],[1,0,1,2,3,4,5]],[[[[0,"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve",[{"hash":1077870003,"name":"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve|oreo-vs:vert|oreo-fs:frag","blocks":[{"name":"OreoCustom","stageFlags":17,"binding":0,"members":[{"name":"textureTransform","type":25,"count":1},{"name":"TextureWeight","type":13,"count":1},{"name":"u_Dissolve_Amount","type":13,"count":1},{"name":"u_Horz_Wind_Spd","type":13,"count":1},{"name":"u_Line_Thickness","type":13,"count":1},{"name":"u_Red_Base_Amount","type":13,"count":1},{"name":"u_Scale_X","type":13,"count":1},{"name":"u_Scale_Y","type":13,"count":1},{"name":"u_Turbulence_Intensity","type":13,"count":1},{"name":"u_Vtcl_Wind_Speed","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"Sprite_GraphicSampler","type":28,"count":1,"stageFlags":17,"binding":1,"defines":[]},{"name":"Dissolve_NoiseSampler","type":28,"count":1,"stageFlags":17,"binding":2,"defines":[]},{"name":"Color_RampSampler","type":28,"count":1,"stageFlags":17,"binding":3,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[],"attributes":[{"name":"a_position","format":32,"location":0,"defines":[]},{"name":"a_normal","format":32,"location":1,"defines":[]},{"name":"a_texCoord","format":21,"location":2,"defines":[]},{"name":"a_tangent","format":44,"location":3,"defines":[]},{"name":"a_joints","location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","format":44,"isInstanced":true,"location":6,"defines":["USE_INSTANCING","CC_USE_BAKED_ANIMATION"]},{"name":"a_matWorld0","format":44,"isInstanced":true,"location":7,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING","CC_USE_LIGHTMAP"]},{"name":"a_localShadowBiasAndProbeId","format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING"]},{"name":"a_sh_linear_const_r","format":44,"isInstanced":true,"location":12,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_g","format":44,"isInstanced":true,"location":13,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_sh_linear_const_b","format":44,"isInstanced":true,"location":14,"defines":["USE_INSTANCING","CC_USE_LIGHT_PROBE"]},{"name":"a_vertexId","format":11,"location":15,"defines":["CC_USE_MORPH"]}],"fragColors":[{"name":"cc_FragColor","typename":"vec4","type":16,"count":1,"stageFlags":16,"location":0,"defines":[]}],"descriptors":[{"rate":0,"blocks":[{"name":"CCMorph","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_displacementWeights","typename":"vec4","type":16,"count":15,"isArray":true},{"name":"cc_displacementTextureInfo","typename":"vec4","type":16,"count":1}],"defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointTextureInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_jointAnimInfo","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","stageFlags":1,"tags":{"builtin":"local"},"members":[{"name":"cc_joints","typename":"vec4","type":16,"count":0,"precision":"highp ","isArray":true}],"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","stageFlags":17,"tags":{"builtin":"local"},"members":[{"name":"cc_matWorld","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matWorldIT","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_lightingMapUVParam","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_localShadowBias","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData1","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_reflectionProbeData2","typename":"vec4","type":16,"count":1,"precision":"highp "}],"defines":["!USE_2D_EFFECT","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","typename":"sampler2D","type":28,"count":1,"stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","typename":"sampler2D","type":28,"count":1,"precision":"highp ","stageFlags":1,"tags":{"builtin":"local"},"defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_spriteTexture","typename":"sampler2D","type":28,"count":1,"stageFlags":17,"tags":{"builtin":"local"},"defines":["USE_2D_SPRITE_FRAME"]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":1,"blocks":[{"name":"OreoCustom","stageFlags":17,"binding":0,"members":[{"name":"textureTransform","type":25,"count":1},{"name":"TextureWeight","type":13,"count":1},{"name":"u_Dissolve_Amount","type":13,"count":1},{"name":"u_Horz_Wind_Spd","type":13,"count":1},{"name":"u_Line_Thickness","type":13,"count":1},{"name":"u_Red_Base_Amount","type":13,"count":1},{"name":"u_Scale_X","type":13,"count":1},{"name":"u_Scale_Y","type":13,"count":1},{"name":"u_Turbulence_Intensity","type":13,"count":1},{"name":"u_Vtcl_Wind_Speed","type":13,"count":1}],"defines":[]}],"samplerTextures":[{"name":"Sprite_GraphicSampler","type":28,"count":1,"stageFlags":17,"binding":1,"defines":[]},{"name":"Dissolve_NoiseSampler","type":28,"count":1,"stageFlags":17,"binding":2,"defines":[]},{"name":"Color_RampSampler","type":28,"count":1,"stageFlags":17,"binding":3,"defines":[]}],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":2,"blocks":[],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]},{"rate":3,"blocks":[{"name":"CCGlobal","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_time","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_screenSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nativeSize","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_probeInfo","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_debug_view_mode","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]},{"name":"CCCamera","stageFlags":17,"tags":{"builtin":"global"},"members":[{"name":"cc_matView","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProj","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_matViewProjInv","typename":"mat4","type":25,"count":1,"precision":"highp "},{"name":"cc_cameraPos","typename":"vec4","type":16,"count":1,"precision":"highp "},{"name":"cc_surfaceTransform","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_screenScale","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_exposure","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitDir","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_mainLitColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientSky","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_ambientGround","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogColor","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogBase","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_fogAdd","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_nearFar","typename":"vec4","type":16,"count":1,"precision":"mediump "},{"name":"cc_viewPort","typename":"vec4","type":16,"count":1,"precision":"mediump "}],"defines":[]}],"samplerTextures":[],"samplers":[],"textures":[],"buffers":[],"images":[],"subpassInputs":[]}],"glsl3":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    in vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    in vec4 a_sh_linear_const_r;\n    in vec4 a_sh_linear_const_g;\n    in vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      layout(std140) uniform CCSkinning {\n        highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n      };\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\nlayout(std140) uniform OreoCustom {\n    mat4 textureTransform;\n    float TextureWeight;\n    float u_Dissolve_Amount;\n    float u_Horz_Wind_Spd;\n    float u_Line_Thickness;\n    float u_Red_Base_Amount;\n    float u_Scale_X;\n    float u_Scale_Y;\n    float u_Turbulence_Intensity;\n    float u_Vtcl_Wind_Speed;\n};\n#if (USE_2D_SPRITE_FRAME)\nuniform sampler2D cc_spriteTexture;\n#endif\nuniform sampler2D Sprite_GraphicSampler;\nuniform sampler2D Dissolve_NoiseSampler;\nuniform sampler2D Color_RampSampler;\nout vec2 transformedUV;\nout vec2 vMainuv;\nout vec2 v_uv;\n#if (USE_2D_EFFECT)\nconst mat4 matWorld = mat4(1.0);\n#else\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nvec2 u_Vector = vec2(1, 1);\nvec2 u_Vector1 = vec2(1, 1);\nfloat u_Float = 0.55;\nfloat u_Edge_Flame_Contrast = 0.28;\nfloat u_Float1 = -1.0;\nvec2 u_Vector2 = vec2(1, 1);\nvec4 vert(void) {\n    StandardVertInput In;\n    CCVertInput(In);\n    #if (USE_2D_EFFECT)\n    #else\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    #endif\n    vec4 output1 = matWorld * vec4(In.position.xyz, 1.0);\n    vec4 output0 = cc_matViewProj * output1;\n    vec4 target_VertPosition = output0;\n    transformedUV = vec2(textureTransform * vec4(a_texCoord.xy, 1.0, 0.0));\n    v_uv = a_texCoord;\n    return target_VertPosition;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform OreoCustom {\n    mat4 textureTransform;\n    float TextureWeight;\n    float u_Dissolve_Amount;\n    float u_Horz_Wind_Spd;\n    float u_Line_Thickness;\n    float u_Red_Base_Amount;\n    float u_Scale_X;\n    float u_Scale_Y;\n    float u_Turbulence_Intensity;\n    float u_Vtcl_Wind_Speed;\n};\n#if (USE_2D_SPRITE_FRAME)\nuniform sampler2D cc_spriteTexture;\n#endif\nuniform sampler2D Sprite_GraphicSampler;\nuniform sampler2D Dissolve_NoiseSampler;\nuniform sampler2D Color_RampSampler;\nin vec2 transformedUV;\nin vec2 vMainuv;\nin vec2 v_uv;\n#if (USE_2D_EFFECT)\nconst mat4 matWorld = mat4(1.0);\n#else\n#if !USE_INSTANCING\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n    highp vec4 cc_localShadowBias;\n    highp vec4 cc_reflectionProbeData1;\n    highp vec4 cc_reflectionProbeData2;\n  };\n#endif\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n  mediump vec4 cc_probeInfo;\n  mediump vec4 cc_debug_view_mode;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_surfaceTransform;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n  mediump vec4 cc_nearFar;\n  mediump vec4 cc_viewPort;\n};\nconst float PI = 3.1415926535897932384626433832795;\nconst float HALF_MIN = 5.96046448e-08;\nconst float LinearEncodePowerApprox = 2.2;\nconst float GammaEncodePowerApprox = 1.0 / LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox = vec3(0.2126, 0.7152, 0.0722);\nconst float Epsilon = 0.0000001;\nconst float rgbdMaxRange = 255.0;\nvec2 u_Vector = vec2(1, 1);\nvec2 u_Vector1 = vec2(1, 1);\nfloat u_Float = 0.55;\nfloat u_Edge_Flame_Contrast = 0.28;\nfloat u_Float1 = -1.0;\nvec2 u_Vector2 = vec2(1, 1);\nvec4 frag(void) {\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead1 = texture(cc_spriteTexture, transformedUV);\n    #else\n    vec4 tempTextureRead1 = texture(Sprite_GraphicSampler, transformedUV);\n    #endif\n    float r = tempTextureRead1.r * TextureWeight;\n    float g = tempTextureRead1.g * TextureWeight;\n    float b = tempTextureRead1.b * TextureWeight;\n    float a = tempTextureRead1.a * TextureWeight;\n    float output5 = 1. - u_Dissolve_Amount;\n    float x = v_uv.x;\n    float y = v_uv.y;\n    float output9 = cc_time.x * u_Horz_Wind_Spd;\n    float output8 = x - output9;\n    float output11 = cc_time.x * u_Vtcl_Wind_Speed;\n    float output10 = y + output11;\n    vec2 xy1 = vec2(output8, output10);\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead2 = texture(cc_spriteTexture, xy1);\n    #else\n    vec4 tempTextureRead2 = texture(Dissolve_NoiseSampler, xy1);\n    #endif\n    vec3 rgb3 = tempTextureRead2.rgb;\n    float r2 = tempTextureRead2.r;\n    vec2 xy = rgb3.xy;\n    float x1 = u_Vector.x;\n    float output12 = x1 * u_Turbulence_Intensity;\n    float output13 = x1 * u_Turbulence_Intensity;\n    vec2 xy3 = vec2(output12, output13);\n    vec2 output7 = mix(v_uv, xy, xy3);\n    float x2 = u_Vector1.x;\n    float y2 = u_Vector1.y;\n    float output14 = x2 / u_Scale_X;\n    float output15 = y2 / u_Scale_Y;\n    vec2 xy5 = vec2(output14, output15);\n    vec2 output6 = output7 * xy5;\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead3 = texture(cc_spriteTexture, output6);\n    #else\n    vec4 tempTextureRead3 = texture(Dissolve_NoiseSampler, output6);\n    #endif\n    float r1 = tempTextureRead3.r;\n    float output4 = step(r1, output5);\n    float output3 = a * output4;\n    vec4 rgba1 = vec4(r, g, b, output3);\n    vec2 xy7 = vec2(r1, 0.0);\n    float output25 = output5 + u_Line_Thickness;\n    float output24 = step(r1, output25);\n    float output23 = output24;\n    float output22 = smoothstep(output23, output4, u_Edge_Flame_Contrast);\n    float output29 = output5 + u_Red_Base_Amount;\n    float output28 = step(r1, output29);\n    float output27 = output28;\n    float output26 = output22 * output27;\n    float output21 = smoothstep(output22, output26, u_Float);\n    vec2 xy8 = vec2(output21, 0.0);\n    vec2 output20 = xy7 + xy8;\n    float output30 = -1.0 * u_Float1;\n    vec2 output19 = u_Float1 + (output20 - -1.0) * (output30 - u_Float1) / (1.0 - -1.0);\n    vec2 output18 = clamp(output19, 0.0, 1.0);\n    vec2 output17 = output18 * u_Vector2;\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead4 = texture(cc_spriteTexture, output17);\n    #else\n    vec4 tempTextureRead4 = texture(Color_RampSampler, output17);\n    #endif\n    vec4 rgba5 = tempTextureRead4.rgba;\n    float r4 = tempTextureRead4.r;\n    float g4 = tempTextureRead4.g;\n    float b4 = tempTextureRead4.b;\n    float r3 = rgba5.r;\n    float g3 = rgba5.g;\n    float b3 = rgba5.b;\n    float a3 = rgba5.a;\n    float output32 = output24 - output4;\n    float output31 = a * output32;\n    float output16 = r3 * output31;\n    float output33 = g3 * output31;\n    float output34 = b3 * output31;\n    float output35 = a3 * output31;\n    vec4 rgba4 = vec4(output16, output33, output34, output35);\n    vec4 output2 = rgba1 + rgba4;\n    float a5 = output2.a;\n    vec4 target_FragColor = vec4(output2.rgb, a5);\n    return target_FragColor;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\n#define QUATER_PI         0.78539816340\n#define HALF_PI           1.57079632679\n#define PI                3.14159265359\n#define PI2               6.28318530718\n#define PI4               12.5663706144\n#define INV_QUATER_PI     1.27323954474\n#define INV_HALF_PI       0.63661977237\n#define INV_PI            0.31830988618\n#define INV_PI2           0.15915494309\n#define INV_PI4           0.07957747155\n#define EPSILON           1e-6\n#define EPSILON_LOWP      1e-4\n#define LOG2              1.442695\n#define EXP_VALUE         2.71828183f\n#define FP_MAX            65504.0\n#define FP_SCALE          0.0009765625\n#define FP_SCALE_INV      1024.0\n#define GRAY_VECTOR       vec3(0.299, 0.587, 0.114)\n#define LIGHT_MAP_TYPE_DISABLED 0\n#define LIGHT_MAP_TYPE_ALL_IN_ONE 1\n#define LIGHT_MAP_TYPE_INDIRECT_OCCLUSION 2\n#define REFLECTION_PROBE_TYPE_NONE 0\n#define REFLECTION_PROBE_TYPE_CUBE 1\n#define REFLECTION_PROBE_TYPE_PLANAR 2\n#define LIGHT_TYPE_DIRECTIONAL 0.0\n#define LIGHT_TYPE_POINT 1.0\n#define LIGHT_TYPE_SPOT 2.0\n#define LIGHT_TYPE_SPHERE 3.0\n#define LIGHT_TYPE_RANGED_DIRECTIONAL 4.0\n#define IS_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_DIRECTIONAL)) < EPSILON_LOWP)\n#define IS_SPHERE_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPHERE)) < EPSILON_LOWP)\n#define IS_SPOT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_SPOT)) < EPSILON_LOWP)\n#define IS_POINT_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_POINT)) < EPSILON_LOWP)\n#define IS_RANGED_DIRECTIONAL_LIGHT(light_type) (abs(float(light_type) - float(LIGHT_TYPE_RANGED_DIRECTIONAL)) < EPSILON_LOWP)\n#define TONE_MAPPING_ACES 0\n#define TONE_MAPPING_LINEAR 1\n#define SURFACES_MAX_TRANSMIT_DEPTH_VALUE 999999.0\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n#endif\n#if USE_INSTANCING\n  #if CC_USE_BAKED_ANIMATION\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if CC_USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n  #if CC_USE_REFLECTION_PROBE || CC_RECEIVE_SHADOW\n    #if CC_RECEIVE_SHADOW\n    #endif\n    attribute vec4 a_localShadowBiasAndProbeId;\n  #endif\n  #if CC_USE_LIGHT_PROBE\n    attribute vec4 a_sh_linear_const_r;\n    attribute vec4 a_sh_linear_const_g;\n    attribute vec4 a_sh_linear_const_b;\n  #endif\n#endif\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n#endif\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\n#if CC_USE_MORPH\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n  #endif\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n  vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n  vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n  }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n  vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n  }\n  #endif\n  void applyMorph (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    normal.xyz = normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    tangent.xyz = tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n  #if CC_USE_BAKED_ANIMATION\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n    void CCGetJointTextureCoords(float pixelsPerJoint, float jointIdx, out highp float x, out highp float y, out highp float invSize)\n    {\n      #if USE_INSTANCING\n        highp float temp = pixelsPerJoint * (a_jointAnimInfo.x * a_jointAnimInfo.y + jointIdx) + a_jointAnimInfo.z;\n      #else\n        highp float temp = pixelsPerJoint * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + jointIdx) + cc_jointTextureInfo.z;\n      #endif\n      invSize = cc_jointTextureInfo.w;\n      highp float tempY = floor(temp * invSize);\n      x = floor(temp - tempY * cc_jointTextureInfo.x);\n      y = (tempY + 0.5) * invSize;\n    }\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      uniform highp sampler2D cc_realtimeJoint;\n    #else\n      uniform highp vec4 cc_joints[CC_JOINT_UNIFORM_CAPACITY * 3];\n    #endif\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(3.0, i, x, y, invSize);\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n        highp float x, y, invSize;\n        CCGetJointTextureCoords(12.0, i, x, y, invSize);\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    #if CC_USE_REAL_TIME_JOINT_TEXTURE\n      #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n        mat4 getJointMatrix (float i) {\n          float x = i;\n          vec4 v1 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 0.5 / 3.0));\n          vec4 v2 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 1.5 / 3.0));\n          vec4 v3 = texture2D(cc_realtimeJoint, vec2( x / 256.0, 2.5 / 3.0));\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #else\n        mat4 getJointMatrix (float i) {\n         float x = 4.0 * i;\n          vec4 v1 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 0.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 0.5 / 3.0)))\n          );\n          vec4 v2 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 1.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 1.5 / 3.0)))\n          );\n          vec4 v3 = vec4(\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 0.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 1.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 2.5)/ 1024.0, 2.5 / 3.0))),\n            decode32(texture2D(cc_realtimeJoint, vec2((x + 3.5)/ 1024.0, 2.5 / 3.0)))\n          );\n          return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n        }\n      #endif\n    #else\n      mat4 getJointMatrix (float i) {\n        int idx = int(i);\n        vec4 v1 = cc_joints[idx * 3];\n        vec4 v2 = cc_joints[idx * 3 + 1];\n        vec4 v3 = cc_joints[idx * 3 + 2];\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout vec4 position, inout vec3 normal, inout vec4 tangent) {\n    mat4 m = skinMatrix();\n    position = m * position;\n    normal = (m * vec4(normal, 0.0)).xyz;\n    tangent.xyz = (m * vec4(tangent.xyz, 0.0)).xyz;\n  }\n#endif\nvoid CCVertInput(inout StandardVertInput In)\n{\n    In.position = vec4(a_position, 1.0);\n    In.normal = a_normal;\n    In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In.position, In.normal, In.tangent);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In.position, In.normal, In.tangent);\n  #endif\n}\n   uniform mat4 textureTransform;\n#if (USE_2D_SPRITE_FRAME)\nuniform sampler2D cc_spriteTexture;\n#endif\nuniform sampler2D Sprite_GraphicSampler;\nuniform sampler2D Dissolve_NoiseSampler;\nuniform sampler2D Color_RampSampler;\nvarying vec2 transformedUV;\nvarying vec2 vMainuv;\nvarying vec2 v_uv;\n#if (USE_2D_EFFECT)\nconst mat4 matWorld = mat4(1.0);\n#else\n#if !USE_INSTANCING\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvoid CCGetWorldMatrixFull(out mat4 matWorld, out mat4 matWorldIT)\n{\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n}\n#endif\nuniform highp mat4 cc_matViewProj;\nvec2 u_Vector = vec2(1, 1);\nvec2 u_Vector1 = vec2(1, 1);\nfloat u_Float = 0.55;\nfloat u_Edge_Flame_Contrast = 0.28;\nfloat u_Float1 = -1.0;\nvec2 u_Vector2 = vec2(1, 1);\nvec4 vert(void) {\n    StandardVertInput In;\n    CCVertInput(In);\n    #if (USE_2D_EFFECT)\n    #else\n    mat4 matWorld, matWorldIT;\n    CCGetWorldMatrixFull(matWorld, matWorldIT);\n    #endif\n    vec4 output1 = matWorld * vec4(In.position.xyz, 1.0);\n    vec4 output0 = cc_matViewProj * output1;\n    vec4 target_VertPosition = output0;\n    transformedUV = vec2(textureTransform * vec4(a_texCoord.xy, 1.0, 0.0));\n    v_uv = a_texCoord;\n    return target_VertPosition;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\n  uniform float TextureWeight;\n  uniform float u_Dissolve_Amount;\n  uniform float u_Horz_Wind_Spd;\n  uniform float u_Line_Thickness;\n  uniform float u_Red_Base_Amount;\n  uniform float u_Scale_X;\n  uniform float u_Scale_Y;\n  uniform float u_Turbulence_Intensity;\n  uniform float u_Vtcl_Wind_Speed;\n#if (USE_2D_SPRITE_FRAME)\nuniform sampler2D cc_spriteTexture;\n#endif\nuniform sampler2D Sprite_GraphicSampler;\nuniform sampler2D Dissolve_NoiseSampler;\nuniform sampler2D Color_RampSampler;\nvarying vec2 transformedUV;\nvarying vec2 vMainuv;\nvarying vec2 v_uv;\n#if (USE_2D_EFFECT)\nconst mat4 matWorld = mat4(1.0);\n#else\n#if !USE_INSTANCING\n  #endif\n#endif\nuniform highp vec4 cc_time;\nconst float PI = 3.1415926535897932384626433832795;\nconst float HALF_MIN = 5.96046448e-08;\nconst float LinearEncodePowerApprox = 2.2;\nconst float GammaEncodePowerApprox = 1.0 / LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox = vec3(0.2126, 0.7152, 0.0722);\nconst float Epsilon = 0.0000001;\nconst float rgbdMaxRange = 255.0;\nvec2 u_Vector = vec2(1, 1);\nvec2 u_Vector1 = vec2(1, 1);\nfloat u_Float = 0.55;\nfloat u_Edge_Flame_Contrast = 0.28;\nfloat u_Float1 = -1.0;\nvec2 u_Vector2 = vec2(1, 1);\nvec4 frag(void) {\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead1 = texture2D(cc_spriteTexture, transformedUV);\n    #else\n    vec4 tempTextureRead1 = texture2D(Sprite_GraphicSampler, transformedUV);\n    #endif\n    float r = tempTextureRead1.r * TextureWeight;\n    float g = tempTextureRead1.g * TextureWeight;\n    float b = tempTextureRead1.b * TextureWeight;\n    float a = tempTextureRead1.a * TextureWeight;\n    float output5 = 1. - u_Dissolve_Amount;\n    float x = v_uv.x;\n    float y = v_uv.y;\n    float output9 = cc_time.x * u_Horz_Wind_Spd;\n    float output8 = x - output9;\n    float output11 = cc_time.x * u_Vtcl_Wind_Speed;\n    float output10 = y + output11;\n    vec2 xy1 = vec2(output8, output10);\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead2 = texture2D(cc_spriteTexture, xy1);\n    #else\n    vec4 tempTextureRead2 = texture2D(Dissolve_NoiseSampler, xy1);\n    #endif\n    vec3 rgb3 = tempTextureRead2.rgb;\n    float r2 = tempTextureRead2.r;\n    vec2 xy = rgb3.xy;\n    float x1 = u_Vector.x;\n    float output12 = x1 * u_Turbulence_Intensity;\n    float output13 = x1 * u_Turbulence_Intensity;\n    vec2 xy3 = vec2(output12, output13);\n    vec2 output7 = mix(v_uv, xy, xy3);\n    float x2 = u_Vector1.x;\n    float y2 = u_Vector1.y;\n    float output14 = x2 / u_Scale_X;\n    float output15 = y2 / u_Scale_Y;\n    vec2 xy5 = vec2(output14, output15);\n    vec2 output6 = output7 * xy5;\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead3 = texture2D(cc_spriteTexture, output6);\n    #else\n    vec4 tempTextureRead3 = texture2D(Dissolve_NoiseSampler, output6);\n    #endif\n    float r1 = tempTextureRead3.r;\n    float output4 = step(r1, output5);\n    float output3 = a * output4;\n    vec4 rgba1 = vec4(r, g, b, output3);\n    vec2 xy7 = vec2(r1, 0.0);\n    float output25 = output5 + u_Line_Thickness;\n    float output24 = step(r1, output25);\n    float output23 = output24;\n    float output22 = smoothstep(output23, output4, u_Edge_Flame_Contrast);\n    float output29 = output5 + u_Red_Base_Amount;\n    float output28 = step(r1, output29);\n    float output27 = output28;\n    float output26 = output22 * output27;\n    float output21 = smoothstep(output22, output26, u_Float);\n    vec2 xy8 = vec2(output21, 0.0);\n    vec2 output20 = xy7 + xy8;\n    float output30 = -1.0 * u_Float1;\n    vec2 output19 = u_Float1 + (output20 - -1.0) * (output30 - u_Float1) / (1.0 - -1.0);\n    vec2 output18 = clamp(output19, 0.0, 1.0);\n    vec2 output17 = output18 * u_Vector2;\n    #if (USE_2D_SPRITE_FRAME)\n    vec4 tempTextureRead4 = texture2D(cc_spriteTexture, output17);\n    #else\n    vec4 tempTextureRead4 = texture2D(Color_RampSampler, output17);\n    #endif\n    vec4 rgba5 = tempTextureRead4.rgba;\n    float r4 = tempTextureRead4.r;\n    float g4 = tempTextureRead4.g;\n    float b4 = tempTextureRead4.b;\n    float r3 = rgba5.r;\n    float g3 = rgba5.g;\n    float b3 = rgba5.b;\n    float a3 = rgba5.a;\n    float output32 = output24 - output4;\n    float output31 = a * output32;\n    float output16 = r3 * output31;\n    float output33 = g3 * output31;\n    float output34 = b3 * output31;\n    float output35 = a3 * output31;\n    vec4 rgba4 = vec4(output16, output33, output34, output35);\n    vec4 output2 = rgba1 + rgba4;\n    float a5 = output2.a;\n    vec4 target_FragColor = vec4(output2.rgb, a5);\n    return target_FragColor;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]}],"samplerTextures":[],"buffers":[],"images":[]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","!CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"CCLocal","defines":["!USE_2D_EFFECT","!USE_INSTANCING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"cc_realtimeJoint","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION","CC_USE_REAL_TIME_JOINT_TEXTURE"]},{"name":"cc_spriteTexture","defines":["USE_2D_SPRITE_FRAME"]}],"buffers":[],"images":[]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":85,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":67}},"defines":[{"name":"USE_INSTANCING","type":"boolean"},{"name":"CC_USE_SKINNING","type":"boolean"},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean"},{"name":"CC_USE_LIGHTMAP","type":"boolean"},{"name":"CC_USE_REFLECTION_PROBE","type":"boolean"},{"name":"CC_RECEIVE_SHADOW","type":"boolean"},{"name":"CC_USE_LIGHT_PROBE","type":"boolean"},{"name":"CC_USE_MORPH","type":"boolean"},{"name":"CC_MORPH_TARGET_COUNT","type":"number","range":[2,8]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean"},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean"},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean"},{"name":"CC_USE_REAL_TIME_JOINT_TEXTURE","type":"boolean"},{"name":"USE_2D_SPRITE_FRAME","type":"boolean"},{"name":"USE_2D_EFFECT","type":"boolean"}]}],[{"name":"opaque","passes":[{"program":"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve|oreo-vs:vert|oreo-fs:frag","properties":{"Color_RampSampler":{"value":"white","type":28},"u_Dissolve_Amount":{"type":13,"value":[0.38]},"Dissolve_NoiseSampler":{"value":"white","type":28},"u_Horz_Wind_Spd":{"type":13,"value":[0]},"u_Line_Thickness":{"type":13,"value":[0.12]},"u_Red_Base_Amount":{"type":13,"value":[0]},"u_Scale_X":{"type":13,"value":[1.07]},"u_Scale_Y":{"type":13,"value":[1.55]},"Sprite_GraphicSampler":{"value":"white","type":28},"TextureWeight":{"type":13,"value":[1]},"u_Turbulence_Intensity":{"type":13,"value":[0]},"u_Vtcl_Wind_Speed":{"type":13,"value":[0.03]}}}]},{"name":"transparent","passes":[{"program":"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve|oreo-vs:vert|oreo-fs:frag","blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"Color_RampSampler":{"value":"white","type":28},"u_Dissolve_Amount":{"type":13,"value":[0.38]},"Dissolve_NoiseSampler":{"value":"white","type":28},"u_Horz_Wind_Spd":{"type":13,"value":[0]},"u_Line_Thickness":{"type":13,"value":[0.12]},"u_Red_Base_Amount":{"type":13,"value":[0]},"u_Scale_X":{"type":13,"value":[1.07]},"u_Scale_Y":{"type":13,"value":[1.55]},"Sprite_GraphicSampler":{"value":"white","type":28},"TextureWeight":{"type":13,"value":[1]},"u_Turbulence_Intensity":{"type":13,"value":[0]},"u_Vtcl_Wind_Speed":{"type":13,"value":[0.03]}}}]},{"name":"add","passes":[{"program":"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve|oreo-vs:vert|oreo-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":1,"blendSrcAlpha":2,"blendDstAlpha":1}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"Color_RampSampler":{"value":"white","type":28},"u_Dissolve_Amount":{"type":13,"value":[0.38]},"Dissolve_NoiseSampler":{"value":"white","type":28},"u_Horz_Wind_Spd":{"type":13,"value":[0]},"u_Line_Thickness":{"type":13,"value":[0.12]},"u_Red_Base_Amount":{"type":13,"value":[0]},"u_Scale_X":{"type":13,"value":[1.07]},"u_Scale_Y":{"type":13,"value":[1.55]},"Sprite_GraphicSampler":{"value":"white","type":28},"TextureWeight":{"type":13,"value":[1]},"u_Turbulence_Intensity":{"type":13,"value":[0]},"u_Vtcl_Wind_Speed":{"type":13,"value":[0.03]}}}]},{"name":"alpha-blend","passes":[{"program":"../Art/images/fx/shaders/color_assisted_dissolve/color_assisted_dissolve|oreo-vs:vert|oreo-fs:frag","rasterizerState":{"cullMode":0},"blendState":{"targets":[{"blend":true,"blendSrc":2,"blendDst":4,"blendSrcAlpha":2,"blendDstAlpha":4}]},"depthStencilState":{"depthTest":true,"depthWrite":false},"properties":{"Color_RampSampler":{"value":"white","type":28},"u_Dissolve_Amount":{"type":13,"value":[0.38]},"Dissolve_NoiseSampler":{"value":"white","type":28},"u_Horz_Wind_Spd":{"type":13,"value":[0]},"u_Line_Thickness":{"type":13,"value":[0.12]},"u_Red_Base_Amount":{"type":13,"value":[0]},"u_Scale_X":{"type":13,"value":[1.07]},"u_Scale_Y":{"type":13,"value":[1.55]},"Sprite_GraphicSampler":{"value":"white","type":28},"TextureWeight":{"type":13,"value":[1]},"u_Turbulence_Intensity":{"type":13,"value":[0]},"u_Vtcl_Wind_Speed":{"type":13,"value":[0.03]}}}]}]]],0,0,[],[],[]],[[[1,"burn_dissolve",1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_INSTANCING":true,"USE_2D_EFFECT":true}],[[[{"u_Dissolve_Amount":0,"u_Horz_Wind_Spd":0.01,"u_Line_Thickness":0.09,"u_Red_Base_Amount":0.01,"u_Scale_X":1,"u_Scale_Y":2,"u_Vtcl_Wind_Speed":0.04},"Color_RampSampler",6,0,"Dissolve_NoiseSampler",6,1,"Sprite_GraphicSampler",6,2]],11]]],0,0,[0,0,0,0],[0,1,2,3],[0,1,2,3]]]]
